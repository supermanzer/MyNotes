<h1 id="domain"><a aria-hidden="true" class="anchor-heading" href="#domain"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Domain</h1>
<p><em>Applying the domain model to the NDBC Python package</em></p>
<hr>
<blockquote>
<p>The <em>domain</em> is a fancy way of saying <em>the problem you're trying to solve</em></p>
</blockquote>
<p>This chapter focuses on naming classes and methods in a manner that utilizes "business jargon" both to help the software components map to user needs as well as make deciding where to add functionality clear.</p>
<p>This is already partly implemented in the naming of the main class (<code>DataBuoy</code>) and the exposed method names.  This chapter also includes examples of building tests of increasing complexity to reflect the required functionalities of the software.  However, let's try to be a bit more rigorous about defining the responsibilities of the <code>DataBuoy</code> class and then evaluate whether the current testing suite does a good job of capturing all this functionality or if there is anything missing/extra.</p>
<h2 id="problem"><a aria-hidden="true" class="anchor-heading" href="#problem"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Problem</h2>
<p>Accessing data from NDBC data stations is cumbersome and not easily scripted.</p>
<h2 id="databuoy-responsibilities---for-now"><a aria-hidden="true" class="anchor-heading" href="#databuoy-responsibilities---for-now"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>DataBuoy responsibilities - for now</h2>
<ul>
<li>
<p>Allow users to request NDBC data packages for a given station for any time period.</p>
<ul>
<li>Return data package as <code>pandas DataFrame</code> if it exists</li>
<li>Return a warning message if it does not</li>
</ul>
</li>
<li>
<p>Allow users to save the current state of a DataBuoy object to disk</p>
</li>
<li>
<p>Allow users to search for data stations based on geographic coordinates</p>
</li>
</ul>
<p>Presently the tests in <code>test_databuoy.py</code> appear to cover all of these aspects of the domain.  However, one aspect covered in this chapter has not been addressed.  That is whether a DataBuoy object should be treated as an Entity or a Value Object.  How should we implement equality?  Two objects could have the same <code>station_id</code> but different data packages and/or time periods.  Hmmmmmm......</p>
<p></p><p></p><div class="portal-container">
<div class="portal-head">
<div class="portal-backlink">
<div class="portal-title">From <span class="portal-text-title">Domain Models</span></div>
<a href="/MyNotes/notes/6erhfc4y3kdjeveybvlqasn" class="portal-arrow">Go to text <span class="right-arrow">â†’</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div><p>One of the concepts that gets introduced in the chapter on domain is the creation of model classes to represent different objects/concepts in my code.  The original structure of the <code>NDBC</code> package contained all necessary functionality in a single <code>DataBuoy</code> class (since my focus was on gathering data from NDBC buoy stations).  </p>
<p>However, this is not ideal and can make maintenance difficult.  To that end I have begun creating classes to represent identified logical/physical entities.</p>
<h2 id="models"><a aria-hidden="true" class="anchor-heading" href="#models"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Models</h2>
<ul>
<li>
<p><code>DataPackage</code> - This is a <code>dataclass</code> that used to encapsulate the details of an individual data package provided from an NDBC data station.  Examples are the standard meteorogical data (<code>stdmet</code>), continuous wind data (<code>cwind</code>), and others.  </p>
</li>
<li>
<p><code>DataPackages</code> - This is a basic class that stores instances of <code>DataPackage</code> and will be a property of the <code>DataStation</code> class.  The primary responsibilities will be to add new or append to existing <code>DataPackage</code> instances as well as return a <code>DataPackage</code> instance when requested.</p>
</li>
<li>
<p><code>DataStation</code> - This model represents the physical station where instruments are deployed and measurements are collected.</p>
</li>
<li>
<p><code>StationInfo</code> - This model represents the information about a specific <code>DataStation</code>, including geographic location, instrument deployment.  </p>
<ul>
<li><strong>note:</strong> - Because different data stations have different instrumentation and other pertinent information, I think this data model will need to be dynamically created using the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.make_dataclass">make_dataclass</a> function.</li>
</ul>
</li>
</ul>
</div></div><p></p><p></p>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/MyNotes/notes/6erhfc4y3kdjeveybvlqasn">Domain Models</a></li>
</ol>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/MyNotes/notes/ax5eormma12p6xh5fqtcxkh">Repository</a></li>
</ul>